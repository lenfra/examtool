# -*- coding: utf-8 -*-
import datetime
import json
import math


class Exam:
    def __init__(self):
        self._course_version = None
        self._course_code = None
        self._exam_id = None
        self.course = None
        self._exam_type = ''
        self._authors = []
        self._language = ''
        self._exam_date = None
        self._time_limit = ''
        self._exam_aids = ''
        self._number_of_questions = 0
        self._total_points = 0.0
        self._ilo_used = set()

        self.preamble = {"Instruction": None,  # Instruction object
                         "Document_Class": None,  # Documentclass object
                         "default_package_id": ''  # String
                         }

        self._grade_limits = {"PF": False,
                              "Percent": False,
                              "ILO_based_grading": False,
                              "Fx": "0",
                              "Pass": "0",
                              "D": "0",
                              "C": "0",
                              "B": "0",
                              "A": "0",
                              }

        self._grade_comment = None

        self.questions = []
        self.bibliography_requirements = set()
        self.declaration_requirements = set()
        self.package_requirements = []

        self.cnx = None

        self._path = {
            'bibtex_path': ''
        }

    def exam_settings_is_complete(self):
        # TODO: Write this method much nicer!
        variables = [self._exam_id, self._course_code, self._course_version,
                     self._exam_type, self._authors, self._exam_date, self._time_limit,
                     self._exam_aids, self._number_of_questions, self._ilo_used,
                     self._language, self.questions]

        for k, v in variables:
            if k == self._authors or self._ilo_used or self.questions:
                if not k:
                    return False
            if k == self._number_of_questions:
                if k == 0:
                    return False
            else:
                if k == '':
                    return False
        for k, v in self.preamble.items():
            if v is None:
                return False

        for k, v in self._grade_limits.items():
            if v is None:
                return False

        return True

    def _gen_title(self):
        """
        Support method for genExam. Retrieves all the information necessary to
        generate the title and formats it accordingly. 
        This is achieved by first calling _getAuthorName to retrieve name, 
        phone and email for the _authors specified in the global variable 
        _examID['_authors'].
        
        Title-section of the exam is then generated by using the information
        set in _courseInfo and finally dynamically generate author-section of 
        the exam, based on number of _authors.

        """
        _author = '\\author{%\n'
        _exam_type = ('\\examtype{%s}\n' % self._exam_type)
        _course_code = ('\\courseid{%s}\n' % (self.course.get_course_code()))
        _course_name = ('\\course{%s}\n' % (self.course.get_course_name_eng()))
        _exam_time = ('\\date{%s}\n' % (self._exam_date.strftime('%Y-%m-%d')))
        # Generate Authors code
        if len(self._authors) == 0:
            _author += '}'
        else:
            for a in self._authors:
                _author += a.gen_author_code()
                if a == self._authors[-1]:  # More _authors
                    _author += '}'
                else:  # More Authors
                    _author += '\\and\n'

        return _exam_type + _course_code + _course_name + _exam_time + _author

    def _generate_description(self):
        """
        Support method for genExam. Retrieves all the information necessary
        to generate the title-section and formats it accordingly. The method
        stores the LaTeX code for the description section in the global 
        variable _examData['descriptions'].
        """

        description = '\\begin{description}\n'
        description += ('\t\\item[Time] %s.\n' % self._time_limit)
        description += ('\t\\item[Exam Aids] %s.\n' % self._exam_aids)
        description += '\t\\item[Maximum points] \\numpoints\n'
        description += '\t\\item[Questions] \\numquestions\n'
        description += '\\end{description}\n'

        return description

    def _generate_grade_limits(self):
        """
        Support method for genExam. Retrieves all the information necessary to
        generate the grade limit-section and formats it accordingly, The code
        is then stored in the global variable _examData['grade_limitss'].
        """
        grade_limits = '\\subsection*{Preliminary grades}\n'
        grade_limits += '\\noindent\n'
        grade_limits += 'The following grading criteria applies:\n'
        if self._grade_limits['Percent']:
            _unit = '\%'
            _percent = True
        else:
            _unit = 'p'
            _percent = False

        if self._grade_limits['PF']:
            if not _percent:
                _pass = math.floor(self._total_points / self._grade_limits['Pass'])
            else:
                _pass = int(self._grade_limits['Pass'])

            grade_limits += ('Pass \(\geq %s %s\),\n'
                             % (_pass, _unit))
        else:
            if not _percent:
                _pass = math.floor(self._total_points * (self._grade_limits['Pass'] / 100))
            else:
                _pass = int(self._grade_limits['Pass'])

            grade_limits += ('E \(\geq %s %s\),\n'
                             % (_pass, _unit))

        if not self._grade_limits['D'] == ("" or None):
            if not _percent:
                _d = math.floor(self._total_points * (self._grade_limits['D'] / 100))
            else:
                _d = int(self._grade_limits['D'])

            grade_limits += ('D \(\geq %s %s\),\n'
                             % (_d, _unit))

        if not self._grade_limits['C'] == ("" or None):
            if not _percent:
                _c = math.floor(self._total_points * (self._grade_limits['C'] / 100))
            else:
                _c = int(self._grade_limits['C'])

            grade_limits += ('C \(\geq %s %s\),\n'
                             % (_c, _unit))

        if not self._grade_limits['B'] == ("" or None):
            if not _percent:
                _b = math.floor(self._total_points * (self._grade_limits['B'] / 100))
            else:
                _b = int(self._grade_limits['B'])

            grade_limits += ('B \(\geq %s %s\),\n'
                             % (_b, _unit))

        if not self._grade_limits['A'] == ("" or None):
            if not _percent:
                _a = math.floor(self._total_points * (self._grade_limits['A'] / 100))
            else:
                _a = int(self._grade_limits['A'])
            grade_limits += ('A \(\geq %s %s\).\n'
                             % (_a, _unit))

        grade_limits += self._grade_comment + '\n'

        return grade_limits

    def get_grade_comment(self):
        return self._grade_comment

    def set_grade_comment(self, comment):
        self._grade_comment = comment
        return True

    def _gen_bib_preamble(self):
        """
        Support method for genExam. Generates LaTeX code for including the
        necessary bib-tex file, based on the files specified in the 
        _path['bibtex_path'] variable. The generated code is then stored in the
        global variable _examData['bibresources']
        """
        bibliography_preamble = ''
        if self._path['bibtex_path'] != '':
            bibliography_preamble += '\\addbibresource{%s}\n' % (self._path['bibtex_path'])

        return bibliography_preamble

    def _gen_print_bibliography(self):
        """
        """
        if self._path['bibtex_path']:
            return '\\printbibliography'
        else:
            return '%No bibliography used'

    def _gen_docclass(self):
        """
        """
        docclass = self.preamble["Document_Class"]

        if docclass is None:
            return '%No document class available!'

        else:
            return docclass.generate_docclass_code()

    def _gen_package_code(self):
        for p in self.package_requirements:
            yield (p.gen_package_code())

    def _gen_declaration_code(self):
        """
        Support method for genExam. Retrieves any declarations that might be 
        used in a question. Must be run AFTER questions have been retrieved.
        The declaration code is added to the global variable 
        _examData['declarations'].
        """
        if not self.declaration_requirements:
            return
        else:

            yield ('%Generated declaration requirements\n')

            for d in self.declaration_requirements:
                if d is not None:
                    yield (d.gen_declaration_code())
        return

    def _gen_instruction_code(self):
        if self.preamble['Instruction']:
            return self.preamble["Instruction"].get_instruction_data() + '\n'
        else:
            return '%No instructions available\n'

    def _generate_covered_ilo(self):
        if not self._ilo_used:
            return None

        _covered_ilo = '\\begin{itemize}\n'
        try:
            for _ilo in sorted(self._ilo_used, key=lambda ilo: int(ilo[0][11:])):
                _covered_ilo += '\\item ILO: %s -- %s \n' % (_ilo[0][11:], _ilo[1])
            _covered_ilo += '\\end{itemize}\n'
        except:
            print("Problem with soring ILO's")

        return _covered_ilo

    def get_exam_code(self):
        # Building the exam.
        exam = ''
        exam += self._gen_docclass()  # print document class
        for p in self._gen_package_code():  # exam += packages
            exam += p
        exam += '\n'
        exam += self._gen_bib_preamble()
        exam += '%\\printanswers\n'
        exam += self._gen_title()  # exam += title
        exam += '\n'
        for d in self._gen_declaration_code():  # exam += declarations
            exam += d
        exam += ('\n\\begin{document}\n'
                 '\\maketitle\n'
                 '\\thispagestyle{foot}\n'
                 '\n')
        exam += ('\\section*{Instructions}\n'
                 '\\label{sec:instructions}\n'
                 '\\noindent'
                 '\n')
        exam += self._gen_instruction_code()
        exam += self._generate_description()  # exam += exam requirements
        exam += self._generate_grade_limits()
        exam += ('\\section*{Covered ILO}\n'
                 '\\noindent\n'
                 'This exam covers the following Intended Learning Outcomes (ILO)\n'
                 )
        exam += self._generate_covered_ilo()
        exam += ('\\clearpage\n'
                 '\\section*{Questions}\n'
                 '\\noindent'
                 '\n')
        exam += 'The questions below are not given in any particular order.\n'
        exam += '\\begin{questions}\n'
        exam += self.get_question_code_for_exam()
        exam += '\\end{questions}\n'
        exam += self._gen_print_bibliography()
        exam += '\n'
        exam += '\\end{document}\n'
        return exam

    # Sets and gets
    def get_exam_id(self):
        return self._exam_id

    def set_exam_id(self, exam_id):
        self._exam_id = exam_id

    def get_course(self):
        return self.course

    def set_course(self, course):
        self.course = course

    def get_course_code(self):
        if self.course:
            return self.course.get_course_code()
        else:
            return None

    def get_course_version(self):
        if self.course:
            return self.course.get_course_version()
        else:
            return None

    def get_exam_type(self):
        return self._exam_type

    def set_exam_type(self, exam_type):
        self._exam_type = exam_type

    def get_author_ids(self):
        _author_string = ""
        _len = len(self._authors)

        if _len > 1:
            for _a in range(_len - 1):
                _author_string += str(self._authors[_a].get_id()) + ','

        _author_string += str(self._authors[_len - 1].get_id())

        return _author_string

    def retrieve_authors(self):
        return self._authors

    def set_authors(self, author):
        self._authors = author

    def append_authors(self, author):
        self._authors.append(author)

    def remove_authors(self, author):
        for a in self._authors:
            if a == author:
                self._authors.remove(a)

    def get_exam_date(self):
        return self._exam_date

    def set_exam_date(self, exam_date):
        if isinstance(exam_date, str):
            self._exam_date = datetime.datetime.strptime(exam_date, '%Y-%m-%d %H:%M:%S')

        elif isinstance(exam_date, datetime.datetime):
            self._exam_date = exam_date

        else:
            print('exam date is of type %s, only expect string or datetime.' % type(exam_date))
        return

    def get_time_limit(self):
        return self._time_limit

    def set_time_limit(self, time_limit):
        self._time_limit = time_limit

    def set_total_points(self, points):
        self._total_points = points
        return True

    def get_total_points(self):
        return self._total_points

    def get_exam_aids(self):
        return self._exam_aids

    def set_exam_aids(self, exam_aids):
        self._exam_aids = exam_aids

    def get_number_of_questions(self):
        return self._number_of_questions

    def set_number_of_questions(self, number_of_questions):
        if number_of_questions is (None or ''):
            self._number_of_questions = 0
            return

        try:
            self._number_of_questions = int(number_of_questions)

        except ValueError:
            self._number_of_questions = 0
            print('Unable to set number of questions')

    def get_ilo_ids_string(self):
        """
        Returns a string of all used ILO, this is used for presenting the ILO used in GUI.
        :return:
        """

        _ilo_string = ""
        _ilo_used = list(self._ilo_used)

        for _ilo in _ilo_used:  # Loop all ILO
            _ilo_string += str(_ilo[0] + ' ')

        return _ilo_string[:-1]  # return string except last char.

    def get_ilo(self):
        try:
            return sorted(self._ilo_used, key=lambda ilo: int(ilo[0][11:]))
        except:
            print("Error with sorting ilo")

    def is_ilo_used(self, ilo):
        for _i in self._ilo_used:
            if _i[0] == ilo:
                return True

        return False

    def set_ilo(self, ilo=None):
        if not ilo:
            self._ilo_used = set()
            return

        self._ilo_used = ilo

    def append_ilo(self, ilo):
        if not (ilo == '' or ilo == ' ' or ilo is None):
            self._ilo_used.add(ilo)

    def remove_ilo(self, course_goal):
        _course_goal_to_remove = set()
        for g in self._ilo_used:
            if g == course_goal:
                _course_goal_to_remove.add(g)

        for cg in _course_goal_to_remove:
            self._ilo_used.remove(cg)

    def get_preamble(self, _type=None):
        if _type is None:
            return self.preamble

        else:
            return self.preamble.get(_type, None)

    def set_preamble(self, _type_value):
        for t, v in _type_value:
            self.preamble[t] = v

    def get_language(self):
        return self._language

    def set_language(self, lang):
        self._language = lang

    def get_grade_limits(self, grade=None):
        if grade is None:
            return self._grade_limits
        else:
            return self._grade_limits.get(grade, None)

    def set_grade_limits(self, grade, value):
        if isinstance(value, str):
            self._grade_limits[grade] = float(value)
        else:
            self._grade_limits[grade] = value

        if self._grade_limits["PF"]:
            for k in self._grade_limits.keys():
                if k not in ['Pass', 'PF', 'Percent', 'ILO_based_grading']:
                    self._grade_limits[k] = None

    def get_questions(self):
        return self.questions

    def set_questions(self, questions):
        self.questions = questions

    def clear_questions(self):
        self.questions = []

    def append_questions(self, question):
        self._total_points += question.get_points()
        self._number_of_questions += 1
        self.questions.append(question)

    def remove_questions(self, question_id):
        """
        Remove question from Exam
        :param question_id: question id to remove
        :return:
        """

        if not self.questions:
            return None

        for _q in self.questions:
            if _q.get_question_id() == question_id:
                self._total_points -= _q.get_points()
                self._number_of_questions -= 1
                self.questions.remove(_q)

    def get_question_code_for_exam(self):
        exam = ''
        for q in self.questions:
            exam += q.get_question_code()

        return exam

    def get_question_ids(self):
        """
        :return: List of question id's that is listed in this exam.
        """
        if not self.questions:
            return None
        _id = []
        for _q in self.questions:
            _id.append(_q.get_question_id())

        return _id

    def question_in_exam(self, question_id):
        """
        Checks whether or not question id is in exam.
        :param question_id:
        :return: True of False
        """
        if not self.questions:
            return False

        for _q in self.questions:
            if _q.get_question_id() == question_id:
                return True

        return False

    def get_declaration_requirements(self):
        return self.declaration_requirements

    def set_declaration_requirements(self, declaration_req):
        self.declaration_requirements = declaration_req

    def append_declaration_requirements(self, declaration_req):
        self.declaration_requirements.add(declaration_req)

    def get_bibliography_requirements(self):
        return self.bibliography_requirements

    def set_bibliography_requirements(self, bibliography_requirements):
        self.bibliography_requirements = bibliography_requirements

    def append_bibliography_requirements(self, bibliography_requirements):
        self.bibliography_requirements.add(bibliography_requirements)

    def get_package_requirements(self):
        return self.package_requirements

    def set_package_requirements(self, package):
        self.package_requirements = package

    def append_package_requirements(self, package):
        self.package_requirements.append(package)

    def set_file_path(self, _type, path):
        self._path[_type] = path
        return True

    def get_file_path(self, _type):
        """
        Support method for GUI to get the current path of where the 
        exam is saved
        """
        return self._path[_type]

    def set_connector(self, cnx):
        self.cnx = cnx
        return

    def save_exam(self, keep_results=True):
        """
        Saves the exam so that it will be later possible to reconstruct it.
        """
        if not self.cnx:
            return None

        cursor = self.cnx.cursor()

        # Delete old exam if exist
        cursor.execute("SELECT `exam_id` \
                        FROM Exams \
                        WHERE `exam_id` = ?", (self._exam_id,))
        reply = cursor.fetchall()
        if reply:
            self.remove_exam(keep_results)

        cursor.execute("INSERT INTO `Exams` \
            (`exam_id`, `course_code`, `course_version`, `exam_date`, `language`,\
             `time_limit`, `exam_aids`, `grade_limits`, `exam_type`, `grade_comment`)\
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
                       , (self._exam_id, self.course.get_course_code(),
                          self.course.get_course_version(),
                          self._exam_date, self._language, self._time_limit, self._exam_aids,
                          json.dumps(self._grade_limits), self._exam_type, self._grade_comment))

        cursor.execute("INSERT INTO `Preamble` \
        (`instruction_id`,`document_class_id`,`default_package_id`,`exam_id`)\
         VALUES (?, ?, ?, ?)"
                       , (self.preamble["Instruction"].get_instruction_id(),
                          self.preamble["Document_Class"].get_document_class_id(),
                          self.preamble['default_package_id'], self._exam_id))

        _question_order = 0
        for quest in self.questions:
            cursor.execute("INSERT INTO `Questions_in_Exam`\
             (`exam_id`,`question_id`, `order`) VALUES (?,?,?)"
                           , (self._exam_id, quest.get_question_id(), _question_order))

            _question_order += 1

        for a in self._authors:
            cursor.execute("INSERT INTO `Exam_Authors` (`author_id`,`exam_id`)\
             VALUES (?,?)", (a.get_id(), self._exam_id))

        self.cnx.commit()
        cursor.close()
        return

    def load_exam_info_from_database(self, exam_id, exam_date, language,
                                     time_limit, exam_aids, grade_limit,
                                     exam_type, grade_comment):

        self._exam_id = exam_id
        self.set_exam_date(exam_date)
        self._language = language
        self._time_limit = time_limit
        self._exam_aids = exam_aids
        self._grade_limits = grade_limit
        self._exam_type = exam_type
        self._grade_comment = grade_comment

        return

    def remove_exam(self, keep_results):
        if not self.cnx:
            return None

        cursor = self.cnx.cursor()
        cursor.execute("DELETE FROM Questions_in_Exam\
                       WHERE `exam_id` = ?"
                       , (self._exam_id,))

        cursor.execute("DELETE FROM Preamble\
                        WHERE `exam_id` = ?"
                       , (self._exam_id,))

        cursor.execute("DELETE FROM Exam_Authors\
                        WHERE `exam_id` = ?"
                       , (self._exam_id,))

        if not keep_results:
            cursor.execute("DELETE FROM Exam_Results\
                        WHERE `exam_id` = ?"
                           , (self._exam_id,))

        cursor.execute("DELETE FROM Exams\
                        WHERE `exam_id` = ?"
                       , (self._exam_id,))

        self.cnx.commit()
        cursor.close()
        return
